<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸‰è§’æ¸¬é‡é«”é©—</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            background-color: #f4f4f4;
        }

        #container {
            display: flex;
            flex-direction: row; 
            min-height: 100vh;
        }

        #input-panel {
            width: 300px;
            padding: 20px;
            background-color: #fff;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            overflow-y: auto;
            flex-shrink: 0;
        }

        .setting-group {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        label {
            display: block;
            margin-top: 10px;
            font-weight: bold;
            font-size: 0.9em;
        }

        input, select {
            padding: 5px;
            margin-top: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }

        .bearing-inputs {
            display: grid;
            grid-template-columns: 1fr 1.5fr 1fr 0.5fr; 
            gap: 5px;
            align-items: center;
        }
        .bearing-inputs select, .bearing-inputs input {
            width: 100%;
        }

        button {
            width: 100%;
            padding: 10px;
            margin-top: 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }

        button:hover {
            background-color: #0056b3;
        }

        #visualization-area {
            flex-grow: 1;
            position: relative;
            background-color: #eee;
        }

        #measurement-display {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            z-index: 10;
        }
        
        /* æ‰‹æ©Ÿä»‹é¢å„ªåŒ– */
        @media (max-width: 600px) {
            #container {
                flex-direction: column; 
            }
            #input-panel {
                width: auto;
                order: 1;
            }
            #visualization-area {
                height: 70vh;
                order: 2;
            }
            .bearing-inputs {
                grid-template-columns: repeat(4, 1fr);
            }
        }
    </style>
</head>
<body>

<div id="container">
    
    <section id="input-panel">
        <h2>ğŸ“ åƒæ•¸è¨­å®š</h2>
        
        <div class="setting-group">
            <h3>é«˜å¡”èˆ‡åœ°åŸº</h3>
            <div>
                <label for="height_cd">å¡”é«˜ CD (hå…¬å°º)(å¯é¸å¡«)</label>
                <input type="number" id="height_cd" value="0" placeholder="0 (ç•™ç©ºå‰‡è¨ˆç®—)">
            </div>
            <div>
                <label for="distance_ab">Aã€B è·é›¢ (å…¬å°ºï¼‰</label>
                <input type="number" id="distance_ab" value="100" placeholder="100" required>
            </div>
        </div>

        <div class="setting-group">
            <h3>è§€æ¸¬é» A (ä»°è§’ Î±)</h3>
            <div>
                <label for="angle_alpha">ä»°è§’ (è§’CAD)(åº¦)</label>
                <input type="number" id="angle_alpha" value="45" placeholder="45" required>
            </div>
            <div>
                <label for="bearing_a">æ–¹ä½ï¼š(æ±æˆ–è¥¿) (è§’åº¦) åº¦ (å—æˆ–åŒ—)</label>
                <div class="bearing-inputs">
                    <select id="a_ew">
                        <option value="æ±">æ±</option>
                        <option value="è¥¿">è¥¿</option>
                    </select>
                    <input type="number" id="a_degrees" value="30" placeholder="0-90"> åº¦
                    <select id="a_ns">
                        <option value="åŒ—">åŒ—</option>
                        <option value="å—">å—</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="setting-group">
            <h3>è§€æ¸¬é» B (ä»°è§’ Î²)</h3>
            <div>
                <label for="angle_beta">ä»°è§’ (è§’CBD)(åº¦)</label>
                <input type="number" id="angle_beta" value="30" placeholder="30" required>
            </div>
            <div>
                <label for="bearing_b">æ–¹ä½ï¼š(æ±æˆ–è¥¿) (è§’åº¦) åº¦ (å—æˆ–åŒ—)</label>
                <div class="bearing-inputs">
                    <select id="b_ew">
                        <option value="è¥¿">è¥¿</option>
                        <option value="æ±">æ±</option>
                    </select>
                    <input type="number" id="b_degrees" value="10" placeholder="0-90"> åº¦
                    <select id="b_ns">
                        <option value="åŒ—">åŒ—</option>
                        <option value="å—">å—</option>
                    </select>
                </div>
            </div>
        </div>

        <button id="draw-button">ğŸš€ ç¹ªè£½ä¸‰è§’æ¸¬é‡åœ–</button>
        <button id="reset-button">ğŸ§¹ æ¸…é™¤åƒæ•¸</button>
    </section>

    <section id="visualization-area">
        <div id="measurement-display">
            **è¨ˆç®—çµæœ**<br>
            $CD é•·åº¦ (h): <span id="val_cd">N/A</span><br>
            $è§’CAD(Î±): <span id="val_cad">N/A</span><br>
            $è§’CBD(Î²): <span id="val_cbd">N/A</span><br>
            $è§’ACB(åœ°é¢): <span id="val_acb">N/A</span>
        </div>
    </section>

</div>

<script>
// --- Three.js è¨­ç½® ---
let scene, camera, renderer, controls, directionalLight;
const visualizationArea = document.getElementById('visualization-area');

function initThree() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xeeeeee); 
    camera = new THREE.PerspectiveCamera(75, visualizationArea.clientWidth / visualizationArea.clientHeight, 0.1, 1000);
    camera.position.set(200, 150, 200);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(visualizationArea.clientWidth, visualizationArea.clientHeight);
    visualizationArea.appendChild(renderer.domElement);
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.update();

    const ambientLight = new THREE.AmbientLight(0x404040, 5); 
    scene.add(ambientLight);
    
    directionalLight = new THREE.DirectionalLight(0xffffff, 5);
    directionalLight.position.set(100, 200, 100);
    scene.add(directionalLight);


    function animate() {
        requestAnimationFrame(animate);
        controls.update(); 
        renderer.render(scene, camera);
    }
    animate();
    window.addEventListener('resize', onWindowResize, false);
}

function onWindowResize() {
    camera.aspect = visualizationArea.clientWidth / visualizationArea.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(visualizationArea.clientWidth, visualizationArea.clientHeight);
}

// --- æ•¸å­¸è¨ˆç®—èˆ‡åº§æ¨™è½‰æ› ---

function degToRad(degrees) {
    return degrees * (Math.PI / 180);
}

/**
 * å°‡æ–¹ä½æè¿° (æ±/è¥¿ è§’åº¦åº¦ å—/åŒ—) è½‰æ›ç‚ºåœ°åœ–è§’åº¦ (åŒ—Z+ç‚º 0 åº¦ï¼Œé †æ™‚é‡å¢åŠ )
 * åæ¨™å®šç¾©ï¼šåŒ— (Z+) 0åº¦, è¥¿ (X+) 90åº¦, å— (Z-) 180åº¦, æ± (X-) 270åº¦
 */
function bearingToAngle(ew, degrees, ns) {
    degrees = parseFloat(degrees);
    let angle = 0;

    if (ew === 'æ±') {
        if (ns === 'åŒ—') { // åŒ—æ± (NE) -> ç¬¬å››è±¡é™
            angle = 270 + degrees; 
        } else if (ns === 'å—') { // å—æ± (SE) -> ç¬¬ä¸‰è±¡é™
            angle = 270 - degrees; 
        }
    } else if (ew === 'è¥¿') {
        if (ns === 'å—') { // å—è¥¿ (SW) -> ç¬¬äºŒè±¡é™
            angle = 90 + degrees; 
        } else if (ns === 'åŒ—') { // åŒ—è¥¿ (NW) -> ç¬¬ä¸€è±¡é™
            angle = 90 - degrees; 
        }
    }
    return (angle + 360) % 360; 
}


/**
 * å°‡é» C (å¡”åº•) è¨­ç‚º (0, 0, 0)ï¼Œè¨ˆç®— A é»å’Œ B é»çš„åº§æ¨™ (X, Y, Z)
 */
function polarToCartesian(R, mapAngle) {
    const angle_from_Z_axis = degToRad(mapAngle);

    // X åº§æ¨™ (è¥¿/æ±): X+ç‚ºè¥¿, X-ç‚ºæ±
    const x = R * Math.sin(angle_from_Z_axis); 
    // Z åº§æ¨™ (åŒ—/å—): Z+ç‚ºåŒ—, Z-ç‚ºå—
    const z = R * Math.cos(angle_from_Z_axis); 
    const y = 0;

    return new THREE.Vector3(x, y, z);
}

// --- ç¹ªåœ–é‚è¼¯ ---

function clearScene() {
    for (let i = scene.children.length - 1; i >= 0; i--) {
        const object = scene.children[i];
        if (object.type !== 'AmbientLight' && object.type !== 'PerspectiveCamera' && object.type !== 'Object3D' && object.uuid !== directionalLight.uuid) {
            scene.remove(object);
        }
    }
}

/**
 * ç¹ªè£½è»¸ç·š (åœ°é¢) å’Œæ–¹ä½æ¨™ç¤º
 */
function drawAxes() {
    
    const length = 150;
    const material = new THREE.LineBasicMaterial({ color: 0x808080, linewidth: 3 });
    const offset = 10;
    const labelColor = 0xcc0000;
    const fontSize = 40; // ***å­—é«”æ”¾å¤§***
    
    // æ±è¥¿è»¸ (X è»¸)
    let geometryX = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(-length, 0, 0),
        new THREE.Vector3(length, 0, 0)
    ]);
    scene.add(new THREE.Line(geometryX, material));

    // å—åŒ—è»¸ (Z è»¸)
    let geometryZ = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, -length),
        new THREE.Vector3(0, 0, length)
    ]);
    scene.add(new THREE.Line(geometryZ, material));
    
    // æ± (X-)
    addTextLabel("æ±", new THREE.Vector3(-length - offset, 0, 0), labelColor, fontSize); 
    // è¥¿ (X+)
    addTextLabel("è¥¿", new THREE.Vector3(length + offset, 0, 0), labelColor, fontSize); 
    // åŒ— (Z+)
    addTextLabel("åŒ—", new THREE.Vector3(0, 0, length + offset), labelColor, fontSize);
    // å— (Z-)
    addTextLabel("å—", new THREE.Vector3(0, 0, -length - offset), labelColor, fontSize);
}

/**
 * å¢åŠ æ–‡å­—æ¨™ç±¤ (å¹³é¢ Sprite å¯¦ç¾ï¼Œå­—é«”æ”¾å¤§)
 */
function addTextLabel(text, position, color, fontSize) {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    
    context.font = `Bold ${fontSize}px Arial`; 
    // è®“ç•«å¸ƒæ ¹æ“šæ–‡å­—é•·åº¦èª¿æ•´å¯¬åº¦
    const textWidth = context.measureText(text).width;
    canvas.width = textWidth + 10;
    canvas.height = fontSize + 10;
    
    // é‡æ–°è¨­å®šå­—é«”å’Œé¡è‰²ä¸¦ç¹ªè£½
    context.font = `Bold ${fontSize}px Arial`; 
    context.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
    context.fillText(text, 5, fontSize); 

    const texture = new THREE.CanvasTexture(canvas);
    texture.minFilter = THREE.LinearFilter; // æé«˜ç¸®å°æ™‚çš„æ¸…æ™°åº¦
    
    const spriteMaterial = new THREE.SpriteMaterial({ map: texture, depthTest: false }); // depthTest: false ç¢ºä¿æ¨™ç±¤ä¸è¢«å…¶ä»–ç‰©ä»¶é®æ“‹
    const sprite = new THREE.Sprite(spriteMaterial);
    
    // èª¿æ•´ sprite å¤§å° (èˆ‡ç•«å¸ƒå°ºå¯¸æˆæ¯”ä¾‹)
    sprite.scale.set(canvas.width * 0.5, canvas.height * 0.5, 1); 
    sprite.position.copy(position);
    scene.add(sprite);
}


/**
 * ç¹ªè£½ç·šæ®µ
 */
function drawLine(start, end, hexColor, lineWidth = 2) {
    const material = new THREE.LineBasicMaterial({ color: hexColor, linewidth: lineWidth });
    const geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
    const line = new THREE.Line(geometry, material);
    scene.add(line);
    return line;
}

// --- ä¸»è¦ç¹ªè£½å‡½å¼ ---

function drawTriangulation() {
    clearScene();
    drawAxes(); 
    
    const inputCD = parseFloat(document.getElementById('height_cd').value) || 0;
    const dAB = parseFloat(document.getElementById('distance_ab').value);
    const alpha_deg = parseFloat(document.getElementById('angle_alpha').value);
    const beta_deg = parseFloat(document.getElementById('angle_beta').value);
    
    const a_ew = document.getElementById('a_ew').value;
    const a_ns = document.getElementById('a_ns').value;
    const a_deg = parseFloat(document.getElementById('a_degrees').value);
    const mapAngleA = bearingToAngle(a_ew, a_deg, a_ns); 

    const b_ew = document.getElementById('b_ew').value;
    const b_ns = document.getElementById('b_ns').value;
    const b_deg = parseFloat(document.getElementById('b_degrees').value);
    const mapAngleB = bearingToAngle(b_ew, b_deg, b_ns); 

    if (isNaN(dAB) || dAB <= 0 || isNaN(alpha_deg) || isNaN(beta_deg) || a_deg < 0 || a_deg > 90 || b_deg < 0 || b_deg > 90) {
        alert("è«‹è¼¸å…¥æœ‰æ•ˆçš„è·é›¢å’Œè§’åº¦ï¼ˆåè½‰è§’åº¦éœ€åœ¨ 0-90 åº¦ä¹‹é–“ï¼‰ã€‚");
        return;
    }

    let h_cd = inputCD;
    let r_ac, r_bc; 
    const C = new THREE.Vector3(0, 0, 0); 
    let D; 

    // --- è¨ˆç®—å¡”é«˜å’Œåœ°é¢è·é›¢ (é‚è¼¯ä¸è®Š) ---
    if (h_cd > 0) {
        r_ac = h_cd / Math.tan(degToRad(alpha_deg));
        r_bc = h_cd / Math.tan(degToRad(beta_deg));
    } else {
        let angleACB = Math.abs(mapAngleA - mapAngleB);
        if (angleACB > 180) angleACB = 360 - angleACB;
        const gamma = degToRad(angleACB);
        
        const tanA = Math.tan(degToRad(alpha_deg));
        const tanB = Math.tan(degToRad(beta_deg));
        
        const denominator = (1 / (tanA * tanA)) + (1 / (tanB * tanB)) - (2 * Math.cos(gamma) / (tanA * tanB));

        if (denominator <= 0) { alert("è¼¸å…¥çš„åƒæ•¸åœ¨å¹¾ä½•ä¸Šç„¡æ³•æ§‹æˆä¸€å€‹æœ‰æ•ˆçš„ä¸‰è§’å½¢ã€‚"); return; }
        h_cd = Math.sqrt((dAB * dAB) / denominator);
        r_ac = h_cd / tanA;
        r_bc = h_cd / tanB;
    }
    
    D = new THREE.Vector3(0, h_cd, 0); 
    const A = polarToCartesian(r_ac, mapAngleA); 
    const B = polarToCartesian(r_bc, mapAngleB); 

    // --- ç¹ªè£½é«˜å¡” (ç¾åŒ–) ---
    const towerRadius = Math.max(r_ac, r_bc) * 0.05; 
    const towerColor = 0x8b4513; 

    // 1. å¡”èº« (åœ“æŸ±)
    const towerGeometry = new THREE.CylinderGeometry(towerRadius * 0.5, towerRadius * 1.5, h_cd, 32);
    const towerMaterial = new THREE.MeshPhongMaterial({ color: towerColor, shininess: 30 }); 
    const tower = new THREE.Mesh(towerGeometry, towerMaterial);
    tower.position.set(0, h_cd / 2, 0); 
    scene.add(tower);

    // 2. å¡”å°– (åœ“éŒ)
    const spireHeight = h_cd * 0.1; 
    const spireGeometry = new THREE.ConeGeometry(towerRadius * 0.5, spireHeight, 16);
    const spireMaterial = new THREE.MeshPhongMaterial({ color: 0x404040 }); 
    const spire = new THREE.Mesh(spireGeometry, spireMaterial);
    spire.position.set(0, h_cd + spireHeight / 2, 0); 
    scene.add(spire);

    // 3. å¡”åº•åŸºç¤ (åœ“ç’°)
    const baseGeometry = new THREE.TorusGeometry(towerRadius * 2, towerRadius * 0.3, 16, 100);
    const baseMaterial = new THREE.MeshPhongMaterial({ color: 0x696969 }); 
    const base = new THREE.Mesh(baseGeometry, baseMaterial);
    base.rotation.x = Math.PI / 2; 
    base.position.set(0, 0, 0);
    scene.add(base);
    
    // --- ç¹ªè£½é€£ç·š ---
    drawLine(C, A, 0x00ff00, 2); // AC
    drawLine(A, D, 0x00ff00, 2); // AD
    drawLine(C, B, 0x0000ff, 2); // BC
    drawLine(B, D, 0x0000ff, 2); // BD
    drawLine(A, B, 0xff0000, 2); // AB

    // --- æ¨™ç¤º A, B, C, D é» (å¹³é¢å‘ˆç¾ï¼Œå­—é«”æ”¾å¤§) ---
    const labelOffset = 5; 
    const labelFontSize = 40; // çµ±ä¸€æ”¾å¤§å­—é«”
    const labelColor = 0x000000;
    
    // C é» (å¡”åº•)
    addTextLabel("C", C.clone().add(new THREE.Vector3(0, labelOffset, 0)), labelColor, labelFontSize);
    // D é» (å¡”é ‚)
    addTextLabel("D", D.clone().add(new THREE.Vector3(0, spireHeight + labelOffset, 0)), labelColor, labelFontSize);
    // A é»
    addTextLabel("A", A.clone().add(new THREE.Vector3(0, labelOffset, 0)), labelColor, labelFontSize);
    // B é»
    addTextLabel("B", B.clone().add(new THREE.Vector3(0, labelOffset, 0)), labelColor, labelFontSize);
    
    // --- é¡¯ç¤ºçµæœ ---
    document.getElementById('val_cd').textContent = h_cd.toFixed(2);
    document.getElementById('val_cad').textContent = alpha_deg.toFixed(2) + 'Â°';
    document.getElementById('val_cbd').textContent = beta_deg.toFixed(2) + 'Â°';
    let angleACB = Math.abs(mapAngleA - mapAngleB);
    if (angleACB > 180) angleACB = 360 - angleACB;
    document.getElementById('val_acb').textContent = angleACB.toFixed(2) + 'Â°';
    
    controls.target.set(0, h_cd / 2, 0);
    controls.update();
}

// --- äº‹ä»¶ç›£è½ ---
document.getElementById('draw-button').addEventListener('click', drawTriangulation);
document.getElementById('reset-button').addEventListener('click', () => {
    // é‡è¨­åƒæ•¸å€¼
    document.getElementById('height_cd').value = '0';
    document.getElementById('distance_ab').value = '100';
    document.getElementById('angle_alpha').value = '45';
    document.getElementById('angle_beta').value = '30';
    document.getElementById('a_degrees').value = '30';
    document.getElementById('b_degrees').value = '10';
    document.getElementById('a_ew').value = 'æ±';
    document.getElementById('a_ns').value = 'åŒ—';
    document.getElementById('b_ew').value = 'è¥¿';
    document.getElementById('b_ns').value = 'åŒ—';
    
    clearScene();
    drawAxes();
    
    document.getElementById('val_cd').textContent = 'N/A';
    document.getElementById('val_cad').textContent = 'N/A';
    document.getElementById('val_cbd').textContent = 'N/A';
    document.getElementById('val_acb').textContent = 'N/A';
});

// åˆå§‹åŒ– Three.js å’Œç¹ªè£½åˆå§‹è»¸ç·š
initThree();
drawAxes(); 

</script>
</body>
</html>